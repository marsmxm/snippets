Hello - from /Users/mxm/.vscode/extensions/jaredly.reason-vscode-1.5.2/bin.native
Previous log location: /var/folders/8v/2p2vdhd14j1ds_rqjvxp92pr0000gn/T/lsp.log
Sending notification {"jsonrpc": "2.0", "method": "client/registerCapability", "params": {"registrations": [{"id": "watching", "method": "workspace/didChangeWatchedFiles", "registerOptions": {"watchers": [{"globPattern": "**/bsconfig.json", "globPattern": "**/.merlin"}]}}]}}
Sending response {"id": 0, "jsonrpc": "2.0", "result": {"capabilities": {"textDocumentSync": 1, "hoverProvider": true, "completionProvider": {"resolveProvider": true, "triggerCharacters": ["."]}, "signatureHelpProvider": {"triggerCharacters": ["("]}, "definitionProvider": true, "typeDefinitionProvider": true, "referencesProvider": true, "documentSymbolProvider": true, "codeActionProvider": true, "executeCommandProvider": {"commands": ["reason-language-server.add_to_interface_inner"]}, "codeLensProvider": {"resolveProvider": true}, "documentHighlightProvider": true, "documentRangeFormattingProvider": true, "documentFormattingProvider": true, "documentFormattingProvider": true, "renameProvider": true}}}
Read message 
{"jsonrpc":"2.0","method":"initialized","params":{}}
Read message 
{"jsonrpc":"2.0","method":"workspace/didChangeConfiguration","params":{"settings":{"reason_language_server":{"location":"","build_system_override_by_root":{},"refmt":"","lispRefmt":"","format_width":"80","per_value_codelens":false,"dependencies_codelens":true,"opens_codelens":true,"show_module_path_on_hover":true,"reloadOnChange":false,"show_debug_errors":false,"autoRebuild":true}}}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didOpen","params":{"textDocument":{"uri":"file:///Users/mxm/Learning/snippets/friedman/little-mler/10-building-on-blocks.ml","languageId":"ocaml","version":1,"text":"(*\n** Chapter 10 of The Little MLer:\n** Building On Blocks\n**\n** Code examples assembled by Peteris Krumins (peter@catonmat.net).\n** His blog is at http://www.catonmat.net  --  good coders code, great reuse.\n**\n** Get yourself this wonderful book at Amazon: http://bit.ly/aNenRl\n*)\n\n(* Peano Numbers\n*)\nfun eq_int(x,y)\n    = x=y;                                  (* int*int -> bool *)\n\nfun is_zero(n)\n    = eq_int(n,0);                          (* int -> bool *)\n\nfun succ(n)\n    = n+1;                                  (* int -> int *)\n\nexception Too_small;\n\nfun pred(n)\n    = if eq_int(n,0)\n        then raise Too_small\n        else n-1;                           (* int -> int *)\n\nfun plus(n,m)\n    = if is_zero(n)\n        then m\n        else succ(plus(pred(n),m));         (* int*int -> int *)\n\n(* Try it out.\n*)\nplus(0,1);                                  (* 1 *)\nplus(1,1);                                  (* 2 *)\nplus(2,1);                                  (* 3 *)\n\n(* Now the same using a datatype.\n*)\ndatatype num =\n    Zero\n |  One_more_than of num;\n\nfun is_zero(Zero)\n    = true\n |  is_zero(not_zero)\n    = false;                                (* num -> bool *)\n\nfun pred(Zero)\n    = raise Too_small\n |  pred(One_more_than(n))\n    = n;                                    (* num -> num *)\n\nfun succ(n)\n    = One_more_than(n);                     (* num -> num *)\n\nfun plus(n,m)\n    = if is_zero(n)\n        then m\n        else succ(plus(pred(n),m));         (* num -> num *)\n\n(* Try it.\n*)\nplus(Zero, One_more_than(Zero));                   (* One_more_than(Zero) *)\nplus(One_more_than(Zero), One_more_than(Zero));    (* One_more_than(One_more_than(Zero)) *)\n\n(* Time for building blocks.\n*)\nsignature N =\n    sig\n        type number\n        exception Too_small\n        val succ    : number -> number\n        val pred    : number -> number\n        val is_zero : number -> bool\n    end;\n\n(* Functors!\n*)\nfunctor NumberAsNum()\n    :>\n    N\n    =\n    struct\n        datatype num =\n            Zero\n         |  One_more_than of num\n        type number = num\n        exception Too_small\n        fun succ(n) =\n            One_more_than(n)\n        fun pred(Zero)\n            = raise Too_small\n         |  pred(One_more_than(n))\n            = n\n        fun is_zero(Zero)\n            = true\n         |  is_zero(foo)\n            = false;\n    end;\n\nfunctor NumberAsInt()\n    :>\n    N\n    =\n    struct\n        type number = int\n        exception Too_small\n        fun succ(n) = n + 1\n        fun pred(n)\n            = if n=0\n                then raise Too_small\n                else n-1\n        fun is_zero(n)\n            = n=0\n    end;\n\n(* Structures!\n*)\nstructure IntStruct = NumberAsInt();\nstructure NumStruct = NumberAsNum();\n\n(* Now the same for plus\n*)\nsignature P =\n    sig\n        type number\n        val plus : number*number -> number\n    end;\n\nfunctor PON(structure a_N : N)\n    :>\n    P\n    =\n    struct\n        type number = a_N.number\n        fun plus(n,m)\n            = if a_N.is_zero(n)\n                then m\n                else a_N.succ(plus(a_N.pred(n),m))\n    end;\n\nstructure IntArith = PON(structure a_N = IntStruct);\nstructure NumArith = PON(structure a_N = NumStruct);\n\n(* Now let's try it out!\n*)\n(*\nIntArith.plus(1,2);                         (* 3 *)\nNumArith.plus(Zero, One_more_than(Zero));   (* One_more_than(Zero) *)\n*)\n\n(* Doesn't work because plus operates on numbers and not ints or nums! *)\n\n(* Let's make it work.\n*)\nsignature N_C_R = (* numbers with conceal reveal *)\n    sig\n        type number\n        exception Too_small\n        val conceal : int -> number\n        val succ    : number -> number\n        val pred    : number -> number\n        val is_zero : number -> bool\n        val reveal  : number -> int\n    end;\n\nfunctor NumberAsInt()\n    :>\n    N_C_R\n    =\n    struct\n        type number = int\n        exception Too_small\n        fun conceal(n) = n\n        fun succ(n) = n + 1\n        fun pred(n)\n            = if n=0\n                then raise Too_small\n                else n-1\n        fun is_zero(n)\n            = n=0\n        fun reveal(n) = n\n    end;\n\nfunctor NumberAsNum()\n    :>\n    N_C_R\n    =\n    struct\n        datatype num =\n            Zero\n         |  One_more_than of num\n        type number = num\n        exception Too_small\n        fun conceal(n)\n            = if n=0\n                then Zero\n                else One_more_than(conceal(n-1))\n        fun succ(n) =\n            One_more_than(n)\n        fun pred(Zero)\n            = raise Too_small\n         |  pred(One_more_than(n))\n            = n\n        fun is_zero(Zero)\n            = true\n         |  is_zero(foo)\n            = false;\n        fun reveal(n)\n            = if is_zero(n)\n                then 0\n                else 1 + reveal(pred(n))\n    end;\n\n(* Rebuild the structures.\n*)\nstructure IntStruct = NumberAsInt();\nstructure IntArith = PON(structure a_N = IntStruct);\n\nstructure NumStruct = NumberAsNum();\nstructure NumArith = PON(structure a_N = NumStruct);\n\n(* Try it.\n*)\nNumStruct.reveal(\n  NumStruct.succ(\n    NumStruct.conceal(0)));                 (* 1 *)\n\n(* Doesn't work\nNumStruct.reveal(\n  NumArith.plus(\n    NumStruct.conceal(1),\n    NumStruct.conceal(2)));                 (* 3 *)\n*)\n\n(* We need to say that PON produces structures whose type number is the same\n** as the type number in a_N, the functor's dependency.\n*)\nfunctor PON(structure a_N : N)\n    :>\n    P where type number = a_N.number\n    =\n    struct\n        type number = a_N.number\n        fun plus(n,m)\n            = if a_N.is_zero(n)\n                then m\n                else a_N.succ(plus(a_N.pred(n),m))\n    end;\n\n(* Now let's create plus over nums\n*)\nstructure NumArith = PON(structure a_N = NumStruct);\nstructure IntArith = PON(structure a_N = IntStruct);\n\n(* Try it.\n*)\nNumStruct.reveal(\n  NumArith.plus(\n    NumStruct.conceal(1),\n    NumStruct.conceal(2)));                 (* 3 *)\n\nIntStruct.reveal(\n  IntArith.plus(\n    IntStruct.conceal(1),\n    IntStruct.conceal(2)));                 (* 3 *)\n\n(* The 2nd way out\n*)\nfunctor NumberAsInt2()\n    :>\n    N where type number = int\n    =\n    struct\n        type number = int\n        exception Too_small\n        fun succ(n) = n + 1\n        fun pred(n)\n            = if n=0\n                then raise Too_small\n                else n-1\n        fun is_zero(n)\n            = n=0\n    end;\n\nstructure IntStruct2 = NumberAsInt2();\nstructure IntArith2  = PON(structure a_N = IntStruct2);\n\n(* It should work.\n*)\nIntArith2.plus(1,2);                    (* 3, and it does! *)\n\n(* Can we do the same for NumberasNum2?\n*)\n\n(* We can't \nfunctor NumberAsNum()\n    :>\n    N where type number = num\n    =\n    struct\n        datatype num =\n            Zero\n         |  One_more_than of num\n        type number = num\n        exception Too_small\n        fun succ(n) =\n            One_more_than(n)\n        fun pred(Zero)\n            = raise Too_small\n         |  pred(One_more_than(n))\n            = n\n        fun is_zero(Zero)\n            = true\n         |  is_zero(foo)\n            = false;\n    end;\n*)\n\n(* because in `where type number = num` num is not visible *)\n\n(* similarity\n*)\nsignature S =\n    sig\n        type number1\n        type number2\n        val similar : number1*number2 -> bool\n    end;\n\nfunctor Same(structure a_N : N\n             structure b_N : N)\n    :>\n    S where type number1 = a_N.number\n      where type number2 = b_N.number\n    =\n    struct\n        type number1 = a_N.number\n        type number2 = b_N.number\n        fun sim(n,m)\n            = if a_N.is_zero(n)\n                then b_N.is_zero(m)\n                else\n                    sim(a_N.pred(n), b_N.pred(m))\n        fun similar(n,m)\n            = ((sim(n,m)\n                handle\n                    a_N.Too_small => false)\n                handle\n                    b_N.Too_small => false)\n    end;\n\nstructure SimIntNum = Same(structure a_N = IntStruct\n                           structure b_N = NumStruct);\nstructure SimNumInt = Same(structure a_N = NumStruct\n                           structure b_N = IntStruct);\n\nSimNumInt.similar(\n  NumStruct.conceal(0),\n  IntStruct.conceal(0));                    (* true *)\n\n(* Time for a snack.\n*)\nfun new_plus(x,y)\n    = NumStruct.reveal(\n        NumArith.plus(\n          NumStruct.conceal(x),\n          NumStruct.conceal(y)));\n\nsignature J =\n    sig\n        val new_plus : int*int -> int\n    end;\n\nfunctor NP(structure a_N : N_C_R\n           structure a_P : P\n           sharing type\n             a_N.number\n             =\n             a_P.number)\n    :>\n    J\n    =\n    struct\n        fun new_plus(x,y)\n            = a_N.reveal(\n                a_P.plus(\n                  a_N.conceal(x),\n                  a_N.conceal(y)))\n    end;\n\nstructure NPStruct = NP(structure a_N = NumStruct\n                        structure a_P = NumArith);\n\n(* Another way to say the same\n*)\nstructure NPStruct = NP(structure a_N = NumberAsNum()\n                        structure a_P = PON(structure a_N = a_N));\n\n(* TON\n*)\nsignature T =\n    sig\n        type number\n        val times : number*number -> number\n    end;\n\nfunctor TON(structure a_N : N\n            structure a_P : P\n            sharing type\n              a_N.number\n              =\n              a_P.number)\n    :>\n    T where type number = a_N.number\n    =\n    struct\n        type number = a_N.number\n        fun times(n,m)\n            = if a_N.is_zero(m)\n                then m\n                else a_P.plus(n, times(n,a_N.pred(m)))\n    end;\n\nstructure TONStruct = TON(structure a_N = NumberAsNum()\n                          structure a_P = PON(structure a_N = a_N));\n\n(* type mismatch, not sure why.\nNumStruct.reveal(\n  TONStruct.times(\n    NumStruct.conceal(5),\n    NumStruct.conceal(5)));     (* 25 *)\n*)\n\nstructure TONStruct = TON(structure a_N = NumStruct\n                          structure a_P = NumArith);\n\nNumStruct.reveal(\n  TONStruct.times(\n    NumStruct.conceal(5),\n    NumStruct.conceal(5)));     (* 25 *)\n\n(*****************************************************************************\n*                                                                            *\n* The tenth moral:                                                           *\n*                                                                            *\n* Real programs consist of many components. Specify the dependencies among   *\n* these components using signatures and functors.                            *\n*                                                                            *\n*****************************************************************************)\n\n\n(*\n** Go get yourself this wonderful book and have fun with ML!\n**\n** Shortened URL to the book at Amazon.com: http://bit.ly/aNenRl\n**\n** Sincerely,\n** Peteris Krumins\n** http://www.catonmat.net\n*)\n\n"}}}
Sending notification {"jsonrpc": "2.0", "method": "window/showMessage", "params": {"type": 1, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/mxm/Learning/snippets/friedman/little-mler/10-building-on-blocks.ml"},"range":{"start":{"line":0,"character":0},"end":{"line":0,"character":0}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.018835067749ms
Sending response {"id": 1, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":2,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/mxm/Learning/snippets/friedman/little-mler/10-building-on-blocks.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0290870666504ms
Sending response {"id": 2, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didOpen","params":{"textDocument":{"uri":"file:///Users/mxm/Learning/snippets/friedman/little-mler/ocaml/10-building-on-blocks.ml","languageId":"ocaml","version":1,"text":"module type N =\n  sig\n    type number\n    exception Too_small\n    val is_zero : number -> bool\n    val succ : number -> number\n    val pred : number -> number\n  end\n\nmodule NumberAsNum =\n  functor () ->\n    (struct\n      type number =\n        | Zero\n        | One_more_than of number\n\n      exception Too_small\n\n      let is_zero n = (n = Zero)\n      let succ n = One_more_than n\n\n      let pred = function\n        | Zero -> raise Too_small\n        | One_more_than m -> m\n    end : N)\n\nmodule NumStruct = NumberAsNum()\n\nmodule NumberAsInt =\n  functor () ->\n    (struct\n      type number = int\n\n      exception Too_small\n\n      let is_zero n = (n = 0)\n      let succ n = n + 1\n\n      let pred = function\n        | m when m > 0 -> m - 1\n        | _ -> raise Too_small\n    end : N)\n\nmodule IntStruct = NumberAsInt()\n\n\nmodule type P =\n  sig\n    type number\n    val plus : number -> number -> number\n  end\n\nmodule PON =\n  functor (AN : N) ->\n    (struct\n      type number = AN.number\n\n      let rec plus m n =\n        if AN.is_zero m\n        then n\n        else AN.succ (plus (AN.pred m) n)\n    end : P)\n\nmodule IntArith = PON(IntStruct)\nmodule NumArith = PON(NumStruct)\n\n(* let _ = IntArith.plus 2 3 \nError: This expression has type int but an expression was expected of type IntArith.number *)\n\n;;\n\nmodule type N_C_R =\n  sig\n    include N\n    val conceal : int -> number\n    val reveal : number -> int\n  end\n\nmodule NumberAsNum =\n  functor () ->\n    (struct\n      type number =\n        | Zero\n        | One_more_than of number\n\n      exception Too_small\n\n      let is_zero n = (n = Zero)\n      let succ n = One_more_than n\n\n      let pred = function\n        | Zero -> raise Too_small\n        | One_more_than m -> m\n\n      let rec conceal i =\n        if i = 0\n        then Zero\n        else One_more_than (conceal (i - 1))\n      \n      let rec reveal = function\n          Zero -> 0\n        | One_more_than n -> (reveal n) + 1\n      \n    end : N_C_R)\n\nmodule NumStruct = NumberAsNum()\n\nmodule NumberAsInt =\n  functor () ->\n    (struct\n      type number = int\n\n      exception Too_small\n\n      let is_zero n = (n = 0)\n      let succ n = n + 1\n\n      let pred = function\n        | m when m > 0 -> m - 1\n        | _ -> raise Too_small\n      \n      let conceal i = i\n      let reveal n = n\n    end : N_C_R)\n\nmodule IntStruct = NumberAsInt()\n\nmodule IntArith = PON(IntStruct)\nmodule NumArith = PON(NumStruct)\n\nlet _ = NumStruct.reveal (NumStruct.succ (NumStruct.conceal 0))\n\n(* let _ = NumStruct.reveal (NumArith.plus (NumStruct.conceal 1) (NumStruct.conceal 2))\nError: This expression has type NumStruct.number but an expression was expected of type NumArith.number *)\n\n;;\n\n(* the other syntax for functor *)\nmodule PON (AN : N) : P with type number = AN.number =\n  struct\n    type number = AN.number\n\n    let rec plus m n =\n      if AN.is_zero m\n      then n\n      else AN.succ (plus (AN.pred m) n)\n  end\n\nmodule IntArith = PON(IntStruct)\nmodule NumArith = PON(NumStruct)\n\nlet _ = NumStruct.reveal (NumArith.plus (NumStruct.conceal 1) (NumStruct.conceal 2))\nlet _ = IntStruct.reveal (IntArith.plus (IntStruct.conceal 1) (IntStruct.conceal 2))\n\nmodule NumberAsInt2 () : N with type number = int =\n  struct\n    type number = int\n\n    exception Too_small\n\n    let is_zero n = (n = 0)\n    let succ n = n + 1\n\n    let pred = function\n      | m when m > 0 -> m - 1\n      | _ -> raise Too_small\n    \n    let conceal i = i\n    let reveal n = n\n  end\n\nmodule IntStruct2 = NumberAsInt2()\nmodule IntArith2 = PON(IntStruct2)\n\nlet _ = IntArith2.plus 2 3\n\ntype num =\n    Zero\n  | One_more_than of num\n\nmodule NumberAsNum2 () : N with type number = num =\n  struct\n    type number = num\n\n    exception Too_small\n\n    let is_zero n = (n = Zero)\n    let succ n = One_more_than n\n\n    let pred = function\n      | Zero -> raise Too_small\n      | One_more_than m -> m\n\n    let rec conceal i =\n      if i = 0\n      then Zero\n      else One_more_than (conceal (i - 1))\n    \n    let rec reveal = function\n        Zero -> 0\n      | One_more_than n -> (reveal n) + 1\n    \n  end\n\nmodule NumStruct2 = NumberAsNum2()\nmodule NumArith2 = PON(NumStruct2)\n\n\nmodule type S =\n  sig\n    type number1\n    type number2\n\n    val similar : number1 -> number2 -> bool\n  end\n\nmodule Same (N1 : N) (N2 : N) : S with\n    type number1 = N1.number and\n    type number2 = N2.number =\n  struct\n    type number1 = N1.number\n    type number2 = N2.number\n\n    let rec sim n m =\n      if N1.is_zero n\n      then N2.is_zero m\n      else sim (N1.pred n) (N2.pred m)\n\n    let similar n m =\n      try sim n m\n      with\n          N1.Too_small -> false\n        | N2.Too_small -> false\n  end\n\nmodule SimIntNum = Same (IntStruct2) (NumStruct2)\n\nlet _ = SimIntNum.similar 3 (One_more_than (One_more_than Zero))\n\nmodule type J =\n  sig\n    val new_plus : int -> int -> int\n  end\n\nmodule NP (N1 : N_C_R) \n          (P1 : P with type number = N1.number) : J =\n  struct\n    let new_plus x y =\n      N1.reveal (P1.plus (N1.conceal x) (N1.conceal y))\n  end\n\nmodule NPStruct = NP (NumStruct) (NumArith)\n\nmodule type T =\n  sig\n    type number\n    val times : number -> number -> number\n  end\n\nmodule TON (A_N : N) \n           (A_P : P with type number = A_N.number) \n           : (T with type number = A_N.number) = struct\n  type number = A_N.number\n\n  let rec times n1 n2 =\n    if A_N.is_zero n1\n    then n1\n    else A_P.plus n2 (times (A_N.pred n1) n2)\nend\n\n;;\n\nmodule type Ysig =\n  sig\n    val y : (('a -> 'a) -> ('a -> 'a)) -> ('a -> 'a)\n  end\n\nmodule Yfunc () : Ysig = struct\n  type 'a t = Into of ('a t -> 'a)\n\n  let rec y f =\n    h f (Into (h f))\n  and h f a =\n    f (g a)\n  and g (Into a) x =\n    a (Into a) x\nend\n\nmodule Ystruct = Yfunc ()\n\nlet mk_fact fact n =\n  if n = 0\n  then 1\n  else n * fact (n - 1)\n\n\nlet _ = Ystruct.y mk_fact 10\n"}}}
Sending notification {"jsonrpc": "2.0", "method": "window/showMessage", "params": {"type": 1, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":3,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/mxm/Learning/snippets/friedman/little-mler/ocaml/10-building-on-blocks.ml"},"range":{"start":{"line":0,"character":0},"end":{"line":0,"character":0}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0119209289551ms
Sending response {"id": 3, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":4,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/mxm/Learning/snippets/friedman/little-mler/ocaml/10-building-on-blocks.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0321865081787ms
Sending response {"id": 4, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":5,"method":"shutdown","params":null}
Sending response {"id": 5, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","method":"exit","params":null}
Got exit! Terminating loop
Finished
